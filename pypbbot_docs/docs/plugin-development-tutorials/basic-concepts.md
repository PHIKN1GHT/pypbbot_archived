# 基本概念

## 客户端与服务端

在早期的 QQ 机器人开发技术中，许多框架曾采用类似酷 Q(CoolQ)的设计方案，也即**使用一个支持插件化的机器人程序来登录某一特定 QQ 账户以提供服务**。这种设计方案固然清晰直观，但当需要通过大量 QQ 账户来提供统一的服务时，其弊端就显露了出来：**插件的编写者将不得不自行处理进程间的同步与数据通信等问题，而这类工作对于编程初学者来说往往繁琐易错**_(对于某些经验丰富的开发者来说亦是如此)_。因而，另一批以[NoneBot](https://github.com/nonebot/nonebot)、[ProtobufBot](https://github.com/ProtobufBot/onebot_idl)等为主的框架则采取了相反的设计思路试图解决这个问题：**由支持插件化的框架本身作为服务端，来与多个登陆了某一特定 QQ 账户的客户端程序进行通信**，从而简化了许多原本需要插件编写者进行处理的繁琐工作。这一思路的转变，**极大降低了插件开发者们编写大规模服务程序的难度，也有效提升了整个系统的可扩展性与可维护性**。本框架亦采用了这样的设计方法。

也即是说，在本文以及所有[ProtobufBot](https://github.com/ProtobufBot/onebot_idl)相关的所有文档中，我们把**仅仅实现了 QQ 的消息收发等协议层功能的程序**称为机器人的**客户端(Client)**，而把**负责处理业务逻辑的程序**称为机器人的**服务端(Server)**。

## 应用程序编程接口、事件与消息

在本文档中，如若不加说明，**应用程序编程接口(API)**、**事件(Event)**与**消息(Message)**的定义皆来自于**协议层**(也即[ProtobufBot](https://github.com/ProtobufBot/onebot_idl))。简单的说，在协议层一共具有两大类协议，其一是类似于[远程过程调用(RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call)的协议，通常用于**让服务端向客户端发出请求**，且发出后**都会收到来自客户端的响应**以确认请求被成功执行，比如发送私聊或是群聊消息，这一类协议被称为**应用程序编程接口(API)**；而另一类协议用于**让服务端能够被动接受来自于客户端的消息**，比如当收到私聊消息或好友请求时能够对其进行处理，这一类协议被称为**事件(Event)**。**消息(Message)**则是一种协议层上的复合数据结构，其**描述了一段或多段 QQ 消息的内容**(除了文本消息外，还支持图片、语音等[富文本格式](https://en.wikipedia.org/wiki/Rich_Text_Format))。协议层除了以上三种结构外，还有另一种**用于数据封装**的**数据帧(Frame)**结构，不过这一结构对于插件开发者是透明的，一般不用考虑。


!!! note "注意"
    一般情况下，我们认为事件是一个**只读**的数据合集。

在使用 PyPbBot 开发的过程中，既可以直接对以上三种结构进行操作，也可以使用 PyPbBot 提供的简单封装。相对来说，后者更加简洁易用。

以上结构定义于源代码的`pypbbot.protocol`与`pypbbot.typing`包中。


## 驱动器

**驱动器(Driver)**是本框架的核心概念之一，其含义是指**负责与客户端进行交互的对象**。注意，这里的对象即可以是面向对象编程中的术语，也**可以是一个高阶函数**。默认情况下，PyPbBot 会**为每个客户端创建一个驱动器对象，并为每个事件启创建一个新的协程**。


!!! note "注意"
    当需要使用全局唯一的驱动器时，一般推荐使用单例模式(即修改类的定义为`class MyDriver(BaseDriver, metaclass=SingletonType)`，其中`SingletonType`位于`pypbbot.typing`模块内)。如果需要对驱动器的构造行为进行更加灵活的限制或处理，则只需重载 `__new__` 函数即可。

!!! note "注意"
    单例模式下，重启协议客户端(即断开链接)后驱动器类不会重新实例化。

## 事务、过滤器与处理程序

前文中，我们有提到事件应该是一个状态不可变的结构。但是在处理事件的过程中，我们常常会希望能够**将某些操作或者可变的状态与不可变的事件进行绑定，以方便对事件进行阶段化的、模块化的处理**。**事务(Affair)**正是这一目的的体现。事务即是事件的封装，通常来说事务以事件为基础，且其生命周期通常会略长于事件。

**事务处理程序(Handler)**则是**用于处理事务的函数**。一般来说，事务处理程序需要与某个**事务过滤器(Filter)**绑定。当过滤器对事务返回真值时，表明该事务可被事务处理程序处理。而且，事务处理程序具有优先级。优先级越高，则事务处理程序会更早的接收到这个事务。


## 插件化功能

在前文的例程中，我们通过定义出描述机器人行为的类(即`SimpleDriver`类)实现了一个简单的类驱动器。但是在实际应用场景中，类驱动器过于耦合且难以扩展。因此，PyPbBot提供了插件化开发的功能。插件化开发，也即**使用事务引擎**进行开发，是面向大规模应用的基础。相比类驱动器模式，这种方法更加简便灵活，且易于扩展。

!!! example "例程：plugin_driver.py" 

    使用插件功能的第一步，是将默认的驱动器更换为事务驱动器，也即编写以下代码：

    ```python
    import os
    from pypbbot import app, run_server
    from pypbbot.driver import AffairDriver

    app.driver_builder = AffairDriver
    app.plugin_path = os.path.join('pypbbot_examples', 'plugins')

    if __name__ == '__main__':
        run_server(app='__main__:app', host='localhost', port=8082, reload=True)

    ```

!!! note "注意"
    在示例程序中，使用的插件目录是项目根目录下的`'pypbbot_examples/plugins'`文件夹。**你需要显式指定一个插件目录，否则事务驱动器将不会加载任何插件。**若目录不存在，事务驱动器会为其创建。

!!! note "注意"
    当`run_server`函数的`reload`参数被设为真值时，框架会开启守护线程，自动监视插件源代码目录的变动情况，并进行重载。在插件目录内创建任意.py 文件，即可创建一个插件。一般情况下，PyPbBot 插件即是一个 Python 模块。



