### 客户端与服务端

在早期的 QQ 机器人开发技术中，许多框架曾采用类似酷 Q（CoolQ）的设计方案，也即 **使用一个支持插件化的机器人程序来登录某一特定 QQ 账户以提供服务** 。这种设计方案固然清晰直观，但当需要通过大量 QQ 账户来提供统一的服务时，其弊端就显露了出来： **插件的编写者将不得不自行处理进程间的同步与数据通信等问题，而这类工作对于编程初学者来说往往繁琐易错** _（对于某些经验丰富的开发者来说亦是如此）_。因而，另一批以[NoneBot](https://github.com/nonebot/nonebot)、[ProtobufBot](https://github.com/ProtobufBot/onebot_idl)等为主的框架则采取了相反的设计思路试图解决这个问题： **由支持插件化的框架本身作为服务端，来与多个登陆了某一特定 QQ 账户的客户端程序进行通信** ，从而简化了许多原本需要插件编写者进行处理的繁琐工作。这一思路的转变， **极大降低了插件开发者们编写大规模服务程序的难度，也有效提升了整个系统的可扩展性与可维护性** 。本框架亦采用了这样的设计方法。

也即是说，在本文以及所有[ProtobufBot](https://github.com/ProtobufBot/onebot_idl)相关的所有文档中，我们把 **仅仅实现了 QQ 的消息收发等协议层功能的程序** 称为机器人的 **客户端（Client）** ，而把 **负责处理业务逻辑的程序** 称为机器人的 **服务端（Server）** 。

### 应用程序编程接口、事件与消息

在本文（以及[PyProtobufBot 文档](https://github.com/PHIKN1GHT/pypbbot)）中，如若不加说明， **应用程序编程接口（API）** 、 **事件（Event）** 与 **消息（Message）** 的定义皆来自于 **协议层** （也即[ProtobufBot](https://github.com/ProtobufBot/onebot_idl)）。简单的说，在协议层一共具有两大类协议，其一是类似于[远程过程调用（RPC）](https://en.wikipedia.org/wiki/Remote_procedure_call)的协议，通常用于 **让服务端向客户端发出请求** ，且发出后 **都会收到来自客户端的响应** 以确认请求被成功执行，比如发送私聊或是群聊消息，这一类协议被称为 **应用程序编程接口（API）** ；而另一类协议用于 **让服务端能够被动接受来自于客户端的消息** ，比如当收到私聊消息或好友请求时能够对其进行处理，这一类协议被称为 **事件（Event）** 。 **消息（Message）** 则是一种协议层上的复合数据结构，其 **描述了一段或多段 QQ 消息的内容**（除了文本消息外，还支持图片、语音等[富文本格式](https://en.wikipedia.org/wiki/Rich_Text_Format)）。协议层除了以上三种结构外，还有另一种 **用于数据封装** 的 **数据帧（Frame）** 结构，不过这一结构对于插件开发者是透明的，一般不用考虑。

> **注意：** 一般情况下，我们认为事件是一个 **只读** 的数据合集。

在使用 PyPbBot 开发的过程中，既可以直接对以上三种结构进行操作，也可以使用 PyPbBot 提供的简单封装。相对来说，后者更加简洁易用。

以上结构定义于源代码的`pypbbot.protocol`与`pypbbot.typing`包中。

<h2 id="driver"> 驱动器</h2>

**驱动器（Driver）** 是本框架的核心概念之一，其含义是指 **负责与客户端进行交互的对象** 。注意，这里的对象即可以是面向对象编程中的术语，也 **可以是一个高阶函数** 。默认情况下，PyPbBot 会 **为每个客户端创建一个驱动器对象，并为每个事件启创建一个新的协程** 。

> **注意：** 当需要使用唯一全局驱动器时，一般推荐使用高阶函数，或着使用单例模式（即修改类的定义为`class AffairDriver(BaseDriver, metaclass=SingletonType)`，其中`SingletonType`位于`pypbbot.typing`模块内)。如果需要对驱动器的构造行为进行灵活的限制或处理，则只需重载 `__new__` 函数即可。

### 事务、过滤器与处理程序

前文中，我们有提到事件应该是一个状态不可变的结构。但是在处理事件的过程中，我们常常会希望能够 **将某些操作或者可变的状态与不可变的事件进行绑定，以方便对事件进行阶段化的、模块化的处理** 。 **事务（Affair）** 正是这一目的的体现。事务即是事件的封装，通常来说事务以事件为基础，且其生命周期通常会略长于事件。

**事务处理程序（Handler）** 则是 **用于处理事务的函数** 。一般来说，事务处理程序需要与某个 **事务过滤器（Filter）** 绑定。当过滤器对事务返回真值时，表明该事务可被事务处理程序处理。而且，事务处理程序具有优先级。优先级越高，则事务处理程序会更早的接收到这个事务。
